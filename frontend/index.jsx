/*
 *     Copyright 2023 Tokuhiro Matsuno
 *
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *
 *            http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 */

import React from 'react';
import {flamegraph} from "d3-flame-graph";
import * as d3 from "d3";
import {App} from "./app";

import "./css/main.css";
import 'd3-flame-graph/dist/d3-flamegraph.css'
import {createRoot} from "react-dom/client";

function getApiUrl() {
    let path = new URL(location.href).pathname;
    let reportRegex = /^\/report\/(\d{6}\/[^/]+)$/;
    let match = path.match(reportRegex);
    if (match) {
        return "/result/" + match[1];
    } else {
        return "sample.hprof.analyzed.json";
    }
}

async function getResult() {
    const url = getApiUrl();
    const response = await fetch(url);
    const json = await response.json();
    console.log(json)
    return json;
}

function renderChart(result, id) {
    const chart = document.getElementById(id);

    const flameGraphTitle = document.createElement("h3");
    flameGraphTitle.innerText = "Flame Graph";
    chart.appendChild(flameGraphTitle);

    const flameGraphContainer = document.createElement("div");
    flameGraphContainer.id = "flameGraphContainer";
    chart.appendChild(flameGraphContainer);

    const partitionGraphTitle = document.createElement("h3");
    partitionGraphTitle.innerText = "Partition Graph";
    chart.appendChild(partitionGraphTitle);

    const partitionGraphContainer = document.createElement("div");
    partitionGraphContainer.id = "treeGraphContainer";
    partitionGraphContainer.style.minHeight = "600px";
    chart.appendChild(partitionGraphContainer);

    renderFlameGraph(result, "#" + flameGraphContainer.id)
    renderPartitions(result.analysisReport.flameGraph, "#" + partitionGraphContainer.id)
}

function renderFlameGraph(result, selector) {
    const flamegraphData = result.analysisReport.flameGraph;

    const chart = flamegraph()
        .width(960);

    d3.select(selector)
        .datum(flamegraphData)
        .call(chart);
}

// Following code is generated by the ChatGPT.
//
// I want to render Partitions graph using D3(using d3.partition).
// - write comments in English
// - write in JavaScript
// - render the value as a bytes using GiB, MiB or KiB.
// - write your code as a function.
// - the function takes 2 argument. 1st argument is the data, that have a format of the d3's hierarchy. 2nd argument is the selector of the target node.
// - function name should be `renderPartitions`
// - show the graph as... height is same as the parent-node. width should be scrollable, it always show the full content.
// - for each node, could you coloring each node? I want to apply the vivid color for large node, and dark color for the nodes, that have a small value.
/**
 * Render an icicle diagram based on hierarchical data.
 *
 * @param {Object} hierarchyData - Hierarchical data in D3's hierarchy format.
 * @param {string} targetSelector - The selector for the target node to append the SVG.
 */
function renderPartitions(hierarchyData, targetSelector) {
    // Set up SVG dimensions and margins
    const margin = {top: 10, right: 10, bottom: 10, left: 10};
    const height = 600 - margin.top - margin.bottom;
    const width = document.querySelector(targetSelector).clientWidth - margin.left - margin.right;

    // Color scale for the nodes based on their value (dark for small values, vivid for large values)
    const color = d3.scaleSequential(d3.interpolatePlasma).domain([0, d3.max(hierarchyData.children, d => d.value)]);

    // Create the SVG canvas
    const svg = d3.select(targetSelector)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("font", "10px sans-serif");

    // Create root node from hierarchy data
    const root = d3.hierarchy(hierarchyData)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value);

    // Create the partition layout
    d3.partition()
        .size([height, (root.height + 1) * width / 3])
        (root);

    // Define the rectangles for the partition layout
    const rect = svg.selectAll("g")
        .data(root.descendants())
        .enter().append("g")
        .attr("transform", d => `translate(${d.y0},${d.x0})`);

    rect.append("rect")
        .attr("width", d => d.y1 - d.y0)
        .attr("height", d => d.x1 - d.x0)
        .attr("fill", d => color(d.value));

    rect.append("text")
        .attr("x", 4)
        .attr("y", 13)
        .text(d => `${d.data.name} (${formatBytes(d.value)})`);

    // Format bytes into KiB, MiB, or GiB
    function formatBytes(bytes) {
        if (bytes >= Math.pow(1024, 3)) return (bytes / Math.pow(1024, 3)).toFixed(2) + ' GiB';
        else if (bytes >= Math.pow(1024, 2)) return (bytes / Math.pow(1024, 2)).toFixed(2) + ' MiB';
        else if (bytes >= Math.pow(1024, 1)) return (bytes / Math.pow(1024, 1)).toFixed(2) + ' KiB';
        else return bytes + ' B';
    }
}

async function main() {
    const result = window.HEAPDIVE_RESULT ? window.HEAPDIVE_RESULT : await getResult();
    console.log(result)

    renderChart(result, "chart");

    const root = createRoot(document.getElementById('root'));
    root.render(<App result={result}/>);
}

document.addEventListener("DOMContentLoaded", () => {
    main()
});

